# k8s/values/alloy-node.yaml
fullnameOverride: alloy-node

controller:
  type: 'daemonset'
  hostNetwork: true
  dnsPolicy: ClusterFirstWithHostNet
  resources: 
    requests: { cpu: 100m, memory: 256Mi }
    limits: { memory: 1Gi }

service:
  enabled: false

rbac:
  create: true
  clusterRole:
    rules:
      - apiGroups: [""]
        resources: ["pods", "pods/log", "namespaces", "nodes", "nodes/proxy", "services", "endpoints", "events", "configmaps", "secrets"]
        verbs: ["get", "watch", "list"]
      - nonResourceURLs: ["/metrics", "/metrics/cadvisor"]
        verbs: ["get"]

alloy:
  clustering:
    enabled: false

  extraEnv:
    - name: HOST_IP
      valueFrom:
        fieldRef:
          fieldPath: status.hostIP
    - name: HOSTNAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName

  configMap:
    content: |
      // 1. DISCOVERY
      discovery.kubelet "local_pods" {
        url = "https://" + env("HOST_IP") + ":10250"
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config { insecure_skip_verify = true }
      }

      // 2. METRICS (Kubelet & cAdvisor)
      prometheus.scrape "infra_kubelet" {
        targets = [{
          __address__ = env("HOST_IP") + ":10250",
          job         = "kubelet",
          instance    = env("HOSTNAME"), 
        }]
        forward_to = [prometheus.relabel.infra_enrich.receiver]
        scheme     = "https"
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config { insecure_skip_verify = true }
      }

      prometheus.scrape "infra_cadvisor" {
        targets = [{
          __address__ = env("HOST_IP") + ":10250",
          job         = "cadvisor",
          instance    = env("HOSTNAME"),
        }]
        forward_to = [prometheus.relabel.infra_enrich.receiver]
        scheme     = "https"
        metrics_path = "/metrics/cadvisor"
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config { insecure_skip_verify = true }
      }

      // 3. SCRAPE EXTERNAL NODE EXPORTER
      discovery.kubernetes "node_exporter" {
        role = "pod"
      }

      discovery.relabel "node_exporter_local" {
        targets = discovery.kubernetes.node_exporter.targets
        
        // Filter 1: Must be the node-exporter app
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          regex         = "prometheus-node-exporter"
          action        = "keep"
        }
        
        // Filter 2: Must be on the same Node as this Alloy instance
        rule {
          source_labels = ["__meta_kubernetes_pod_node_name"]
          regex         = env("HOSTNAME")
          action        = "keep"
        }

        // Set Job Name
        rule {
          target_label = "job"
          replacement  = "node-exporter"
        }
      }

      prometheus.scrape "node_infra" {
        targets    = discovery.relabel.node_exporter_local.output
        forward_to = [prometheus.relabel.infra_enrich.receiver]
      }

      // 4. ENRICHMENT & OUTPUT
      prometheus.relabel "infra_enrich" {
        forward_to = [prometheus.remote_write.infra.receiver]
        rule {
          action       = "replace"
          replacement  = "k3s-local"
          target_label = "cluster"
        }
      }

      prometheus.remote_write "infra" {
        endpoint {
          url     = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-k8s" }
        }
      }

      // 5. LOGS (Standard Kubelet Logs)
      discovery.relabel "logs_targets" {
        targets = discovery.kubelet.local_pods.targets
        
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }
        
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }
        
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }
        
        rule {
          action       = "replace"
          replacement  = "k3s-local"
          target_label = "cluster"
        }
      }

      // 5.1 PLATFORM-K8S
      discovery.relabel "logs_k8s" {
        targets = discovery.relabel.logs_targets.output
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          regex         = "kube-system|default|argocd-system|public|ingress-nginx"
          action        = "keep"
        }
      }
      loki.source.kubernetes "k8s" {
        targets    = discovery.relabel.logs_k8s.output
        forward_to = [loki.write.k8s.receiver]
      }
      loki.write "k8s" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          tenant_id = "platform-k8s"
        }
      }

      // 5.2 PLATFORM-OBS
      discovery.relabel "logs_obs" {
        targets = discovery.relabel.logs_targets.output
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          regex         = "observability-prd"
          action        = "keep"
        }
      }
      loki.source.kubernetes "obs" {
        targets    = discovery.relabel.logs_obs.output
        forward_to = [loki.write.obs.receiver]
      }
      loki.write "obs" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          tenant_id = "platform-obs"
        }
      }

      // 5.3 DEVTEAM-1
      discovery.relabel "logs_dev" {
        targets = discovery.relabel.logs_targets.output
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          regex         = "devteam-1"
          action        = "keep"
        }
      }
      loki.source.kubernetes "dev" {
        targets    = discovery.relabel.logs_dev.output
        forward_to = [loki.write.dev.receiver]
      }
      loki.write "dev" {
        endpoint {
          url = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          tenant_id = "devteam-1"
        }
      }

      // 6. SELF MONITORING (Internal Metrics -> platform-obs)
      // âœ… This fixes the missing dashboard variables
      prometheus.scrape "alloy_self" {
        targets = [{
          __address__ = "127.0.0.1:12345",
          cluster     = "k3s-local",
          namespace   = "observability-prd",
          job         = "alloy",
          instance    = env("HOSTNAME"),
        }]
        forward_to = [prometheus.remote_write.obs.receiver]
      }

      prometheus.remote_write "obs" {
        endpoint {
          url     = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-obs" }
        }
      }