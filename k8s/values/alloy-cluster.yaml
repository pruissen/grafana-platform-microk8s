# k8s/values/alloy-cluster.yaml
# ROLE: Deployment for Cluster-Wide Metrics & Events

fullnameOverride: alloy-cluster

controller:
  type: deployment
  replicas: 1
  resources: 
    requests: { cpu: 50m, memory: 128Mi }
    limits: { memory: 512Mi }

service:
  enabled: true
  type: ClusterIP

rbac:
  create: true
  clusterRole:
    rules:
      - apiGroups: [""]
        resources: ["pods", "namespaces", "nodes", "services", "endpoints", "events"]
        verbs: ["get", "watch", "list"]

alloy:
  clustering:
    enabled: true

  configMap:
    content: |
      // 1. CLUSTER EVENTS
      loki.source.kubernetes_events "cluster_events" {
        job_name   = "integrations/kubernetes/eventhandler"
        forward_to = [loki.process.events_enrich.receiver]
      }

      loki.process "events_enrich" {
        forward_to = [loki.write.infra.receiver]
        stage.static_labels { 
            values = { "cluster" = "k3s-local" } 
        }
      }

      loki.write "infra" {
        endpoint {
          url        = "http://loki-gateway.observability-prd.svc:80/loki/api/v1/push"
          tenant_id = "platform-k8s"
        }
      }

      // 2. CLUSTER METRICS
      discovery.kubernetes "k8s_services"  { role = "service" }

      // 2.1 PLATFORM-K8S (Infrastructure)
      discovery.relabel "infra_services" {
        targets = discovery.kubernetes.k8s_services.targets
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          regex         = "kube-system|default|argocd-system|public|ingress-nginx"
          action        = "keep"
        }
        rule {
          source_labels = ["__meta_kubernetes_service_name"]
          target_label  = "job"
        }
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }
        rule {
          source_labels = ["__meta_kubernetes_service_name"]
          regex         = "kubernetes"
          target_label  = "__scheme__"
          replacement   = "https"
        }
      }

      prometheus.scrape "infra_services" {
        targets    = discovery.relabel.infra_services.output
        forward_to = [prometheus.remote_write.infra.receiver]
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config { insecure_skip_verify = true }
      }

      // 2.2 KUBE STATE METRICS (Explicit Scrape)
      discovery.relabel "ksm" {
        targets = discovery.kubernetes.k8s_services.targets
        rule {
          source_labels = ["__meta_kubernetes_service_label_app_kubernetes_io_name"]
          regex         = "kube-state-metrics"
          action        = "keep"
        }
        rule {
          target_label = "job"
          replacement  = "kube-state-metrics"
        }
      }

      prometheus.scrape "ksm" {
        targets    = discovery.relabel.ksm.output
        forward_to = [prometheus.remote_write.infra.receiver]
      }

      prometheus.remote_write "infra" {
        endpoint {
          url     = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-k8s" }
        }
        external_labels = { "cluster" = "k3s-local" }
      }

      // 3. SELF MONITORING (Internal Metrics -> platform-obs)
      // âœ… This fixes the missing dashboard variables
      prometheus.scrape "alloy_self" {
        targets = [{
          __address__ = "127.0.0.1:12345",
          cluster     = "k3s-local",
          namespace   = "observability-prd",
          job         = "alloy",
          instance    = "alloy-cluster",
        }]
        forward_to = [prometheus.remote_write.obs.receiver]
      }

      prometheus.remote_write "obs" {
        endpoint {
          url     = "http://mimir-nginx.observability-prd.svc:80/api/v1/push"
          headers = { "X-Scope-OrgID" = "platform-obs" }
        }
      }